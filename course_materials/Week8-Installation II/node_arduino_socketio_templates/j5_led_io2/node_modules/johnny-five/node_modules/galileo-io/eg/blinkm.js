var io = require("mraa");
var blinkm = new io.I2c(0);

var BlinkM = {
  0x09: "ADDRESS",
  0x63: "FADE_TO_RGB",
  0x43: "FADE_TO_RANDOM_RGB",
  0x70: "SCRIPT_PLAY",
  0x6f: "SCRIPT_STOP",
  0x6e: "SET_RGB",
  0x67: "GET_RGB",
};

Object.keys(BlinkM).forEach(function(key) {
  // Turn the value into a key and
  // the key into an int value
  BlinkM[BlinkM[key]] = key | 0;
});



var buffer = new Buffer(4);


blinkm.address(BlinkM.ADDRESS);


blinkm.write(new Buffer([BlinkM.SET_RGB, 0, 0, 0]));
blinkm.write(new Buffer([BlinkM.SET_RGB, 255, 0, 0]));



//   console.log("READY");

//   // http://thingm.com/fileadmin/thingm/downloads/BlinkM_datasheet.pdf
//   this.i2cWrite(BlinkM.ADDRESS, BlinkM.SCRIPT_STOP);

//   this.i2cWrite(BlinkM.ADDRESS, BlinkM.SET_RGB, [0, 0, 0]);

//   this.i2cWrite(BlinkM.ADDRESS, BlinkM.SET_RGB, [127, 127, 127]);

//   // setInterval(function() {
//   //   var color = colors[index++];

//   //   this.i2cWrite(BlinkM.ADDRESS, BlinkM.FADE_TO_RGB, rainbow[color]);

//   //   this.i2cRead(BlinkM.ADDRESS, BlinkM.GET_RGB, 3, function(data) {
//   //     console.log("RGB: [%s]", data);
//   //   });

//   //   if (index === colors.length) {
//   //     index = 0;
//   //   }
//   // }.bind(this), 1000);
// });

// function scale(value, inMin, inMax, outMin, outMax) {
//   return (value - inMin) * (outMax - outMin) /
//     (inMax - inMin) + outMin;
// }

// function to7bit(value) {
//   return scale(value, 0, 255, 0, 127) | 0;
// }
